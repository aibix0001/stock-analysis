# üìã Anforderungen - Aktienanalyse-Verwaltung

**Datum**: 24.07.2025  
**Projekt**: aktienanalyse-verwaltung  
**Status**: üìù Anforderungsaufnahme

---

## üéØ Projekt√ºbersicht

Das Aktienanalyse-Verwaltungssystem ist **Teil eines integrierten 4-Projekt-√ñkosystems** f√ºr umfassende Aktienanalyse und Portfolio-Management.

### üèóÔ∏è √ñkosystem-Integration

**aktienanalyse-verwaltung** ist das **Trading & Depot-Management Modul** im **Aktienanalyse-√ñkosystem**:

```
Aktienanalyse-√ñkosystem (4 Teilprojekte):
‚îú‚îÄ‚îÄ üìà aktienanalyse (Basis-System)        ‚Üí Stock Analysis & Scoring
‚îú‚îÄ‚îÄ üßÆ aktienanalyse-auswertung (Analytics) ‚Üí Performance Analysis & Reporting  
‚îú‚îÄ‚îÄ üíº aktienanalyse-verwaltung (Trading)   ‚Üí **Depot Management & Trading** ‚≠ê
‚îî‚îÄ‚îÄ üåê data-web-app (Frontend)             ‚Üí Unified Web Dashboard
```

**Cross-System Integration**:
- **Input**: Stock-Scores von `aktienanalyse`, Performance-Daten von `auswertung`
- **Output**: Portfolio-Daten an `auswertung`, Trading-UI an `data-web-app`
- **Intelligence**: Auto-Import besserer Stocks basierend auf Cross-System Performance-Vergleich

**üîí Scope**: Privates √ñkosystem f√ºr Einzelbenutzer - keine Multi-User-Funktionalit√§t erforderlich.

---

## üìä Hauptanforderungen

### 1. üíº Lokale Depot-Verwaltung

**Anforderung**: Ein lokales Aktien-Depot soll vollst√§ndig verwaltet werden k√∂nnen

**Details**:
- Lokale Speicherung aller Depot-Positionen
- Verwaltung von Aktienbest√§nden (Anzahl, Kaufkurs, Kaufdatum)
- Portfolio-√úbersicht mit aktuellen Kursen
- **Enhanced Performance-Tracking**: Brutto- und Netto-Gewinn/Verlust-Berechnung

**‚úÖ ERWEITERTE PERFORMANCE-BERECHNUNG**:
- **Brutto-Performance**: Reine Kursdifferenz ohne Nebenkosten
- **Netto-Performance**: Inklusive Steuern und Geb√ºhren (optional aktivierbar)
- **Steuerberechnung nach deutschem Steuerrecht (2025)**:
  - **Kapitalertragsteuer (KESt)**: 25% auf Kapitalgewinne
  - **Solidarit√§tszuschlag (SolZ)**: 5,5% auf KESt (= 1,375% auf Gewinne)
  - **Kirchensteuer (KiSt)**: 8% (evangelisch) oder 9% (katholisch) auf KESt (optional)
  - **KEINE Optimierungen**: Keine Abschreibungen, Verlustverrechnung oder steuerliche Tricks
  - **Standard-Berechnung**: Einfache lineare Steuerberechnung ohne komplexe Strategien
- **Geb√ºhrentracking**: Kauf-/Verkaufgeb√ºhren, B√∂rsenplatzentgelte, Spreads
- **Dividenden**: Brutto/Netto-Aussch√ºttungen mit Quellensteuer-Anrechnung
- **Vergleichsmodi**: Umschaltbar zwischen Brutto- und Netto-Sicht

**‚úÖ PERFORMANCE-RANKING & DEPOT-SORTIERUNG**:
- **Netto-Gewinn-Vergleich**: Zeitraum-normalisierte Performance aller Positionen
- **Automatische Depot-Sortierung**: Nach Netto-Performance-Ranking
- **Zeitraum-Anpassung**: Gleiche Berechnungsbasis f√ºr faire Vergleiche
- **Multi-Kriterien-Sortierung**: Netto-Gewinn, ROI, Sharpe-Ratio, Volatilit√§t
- **Performance-Heatmap**: Visuelle Darstellung der Gewinner/Verlierer
- **Rebalancing-Vorschl√§ge**: Auf Basis der Performance-Analyse

**Fragen zur Kl√§rung**:
- Welche Daten sollen f√ºr jede Position gespeichert werden?
- Soll es mehrere Depots/Portfolios geben k√∂nnen?
- **Steuer-Konfiguration**: Pers√∂nliche Steuers√§tze (KESt, SolZ, KiSt) konfigurierbar?
- **Geb√ºhren-Modell**: Automatische Geb√ºhren-Erkennung von Bitpanda oder manuelle Eingabe?
- **W√§hrungsumrechnung**: Steuerberechnung bei Fremdw√§hrungs-Assets (USD/EUR)?
- **Verlustvortrag**: Sollen Verluste f√ºr steuerliche Verrechnung gespeichert werden?
- **Performance-Zeitr√§ume**: Welche Standard-Zeitr√§ume f√ºr Vergleiche (1M, 3M, 6M, 1Y, YTD)?
- **Sortier-Kriterien**: Priorit√§t der Sortierkriterien (Netto-Gewinn, ROI, Risk-Adjusted Return)?
- **Benchmark-Vergleich**: Sollen Positionen gegen Markt-Indices verglichen werden?

### 2. üîÑ Online-Broker Integration

**Anforderung**: Kauf- und Verkaufauftr√§ge sollen automatisch an ein Online-Depot bei einem Broker ausgef√ºhrt werden

**Details**:
- Automatische Synchronisation zwischen lokalem und Online-Depot
- Ausf√ºhrung von Buy/Sell-Orders √ºber Broker-API
- Parallelf√ºhrung: Lokales Depot + Online-Broker-Depot

**‚úÖ BROKER-AUSWAHL ENTSCHIEDEN: Bitpanda Pro**

**Bitpanda Pro API Details**:
- **Base URL**: `https://api.exchange.bitpanda.com/public/v1`
- **API-Typ**: REST + WebSocket
- **Rate Limit**: 120 Requests/Minute
- **Authentifizierung**: Bearer Token (API Key)

**Verf√ºgbare Order-Typen**:
- ‚úÖ **Market Orders** - Sofortige Ausf√ºhrung zum aktuellen Marktpreis
- ‚úÖ **Limit Orders** - Ausf√ºhrung bei Erreichen des Zielpreises
- ‚úÖ **Stop-Limit Orders** - Stop-Loss mit Preislimit
- ‚úÖ **Good 'til Cancelled (GtC)** - Standard f√ºr Limit Orders
- ‚úÖ **Good 'til Time (GtT)** - Zeitgesteuerte Order (bis 1 Woche)
- ‚úÖ **Immediate or Cancel (IoC)** - Sofort oder stornieren
- ‚úÖ **Fill or Kill (FoK)** - Komplett oder gar nicht

**API-Berechtigungen**:
- **Read**: Account-Balances, Order-History, Market-Data
- **Trade**: Order-Placement, Order-Cancellation
- **Withdraw**: Ein-/Auszahlungen (nicht f√ºr Aktien-Trading relevant)

**WebSocket Real-time Features**:
- Account Feed (Balance-Updates)
- Market Data Feed (Preise, Ticker)
- Order Book Updates
- Candlestick-Streaming

**‚úÖ ASSET-SUPPORT BEST√ÑTIGT**: Bitpanda unterst√ºtzt **Aktien + ETFs + Crypto**

**Verf√ºgbare Instrumente**:
- ‚úÖ **Aktien**: Einzelaktien verschiedener M√§rkte
- ‚úÖ **ETFs**: Exchange Traded Funds  
- ‚úÖ **Kryptow√§hrungen**: Bitcoin, Ethereum, etc.
- ‚úÖ **Fiat-W√§hrungen**: EUR, USD f√ºr Trading-Pairs

**‚úÖ BITPANDA API ALS DATENQUELLE ERG√ÑNZT**:
- **Market Data Integration**: Bitpanda Pro API als prim√§re Datenquelle f√ºr aktienanalyse
- **Dual-Purpose**: Trading-API (verwaltung) + Market Data (aktienanalyse)  
- **Real-time Streams**: WebSocket f√ºr Live-Kursanalyse und Vorhersagen
- **Enhanced Analytics**: Liquidit√§ts-Scores, Volume-Profile, Momentum-Indikatoren
- **Rate-Limited Access**: 100/120 Requests/Min f√ºr Public/Private API

**Verbleibende Fragen**:
- Sollen Orders sofort oder zeitgesteuert ausgef√ºhrt werden?
- Wie soll mit Teilausf√ºhrungen umgegangen werden?
- Welche spezifischen M√§rkte/B√∂rsen sind √ºber Bitpanda verf√ºgbar?

### 3. üì• Cross-System Aktien-Intelligence

**Anforderung**: Intelligente Aktien-√úbernahme aus dem gesamten √ñkosystem mit Cross-System Performance-Vergleich

**Details**:
- **Multi-Source Import**: Aktien aus allen 3 Backend-Systemen (aktienanalyse, auswertung, data-web-app)
- **Intelligence-Algorithmus**: Performance-Vergleich zwischen allen Systemen
- **Watchlist-Modus**: √úbernahme mit 0 Bestand f√ºr sp√§tere Kaufentscheidungen
- **Cross-System Validation**: Duplikatserkennung √ºber alle Projekte

**‚úÖ √ñKOSYSTEM-INTEGRATION**:
- **Primary Source**: `aktienanalyse` ‚Üí Top-Scored Stocks aus Technical Analysis
- **Secondary Source**: `auswertung` ‚Üí High-Performance Stocks aus Portfolio Analytics
- **Tertiary Source**: `data-web-app` ‚Üí User-definierte Watchlist-Inputs
- **Performance Matrix**: 4-System Performance-Cross-Correlation-Analyse
- **Auto-Import Logic**: Multi-Kriterien-Algorithmus f√ºr beste Stock-Selection

**Cross-System Intelligence-Algorithmus**:
```python
def cross_system_intelligence():
    # System 1: aktienanalyse Technical Scores
    technical_scores = get_aktienanalyse_top_performers()
    
    # System 2: auswertung Performance Analytics
    analytics_scores = get_auswertung_performance_rankings()
    
    # System 3: verwaltung Current Depot Performance
    depot_performance = get_current_depot_rankings()
    
    # System 4: data-web-app User Preferences
    user_preferences = get_user_watchlist_signals()
    
    # Cross-System Correlation Matrix
    correlation_matrix = calculate_cross_system_correlations(
        technical_scores, analytics_scores, depot_performance, user_preferences
    )
    
    # Multi-Criteria Decision Algorithm
    import_candidates = select_best_performers(
        correlation_matrix,
        weights={'technical': 0.4, 'analytics': 0.3, 'depot': 0.2, 'user': 0.1}
    )
    
    # Auto-Import to Depot (0 Bestand)
    for stock in import_candidates:
        if stock.combined_score > worst_depot_position.score:
            auto_import_to_watchlist(stock, quantity=0)
    
    return import_candidates
```

**Performance-Vergleichslogik**:
- **Depot-Performance**: Netto-Gewinn-Ranking der aktuellen Positionen
- **Analyse-Performance**: Bewertungen aus aktienanalyse-auswertung
- **√úbernahme-Kriterium**: Aktie aus aktienanalyse besser als schlechteste Depot-Position
- **Watchlist-Modus**: Neue Aktien mit 0 Bestand f√ºr sp√§tere Kaufentscheidungen

**Fragen zur Kl√§rung**:
- **Performance-Mapping**: Wie werden aktienanalyse-Scores mit Depot-Rankings verglichen?
- **√úbernahme-Schwellwert**: Ab welcher Performance-Differenz √ºbernehmen?
- **Sync-Frequenz**: Wie oft soll der Vergleich durchgef√ºhrt werden?
- **Filterkriterien**: Zus√§tzliche Filter neben Performance (Sektor, Marktkapitalisierung)?
- **Benachrichtigungen**: Sollen neue √úbernahmen dem Benutzer gemeldet werden?

### 4. üè† Deployment und Integration

**Anforderung**: Das Programm soll dauerhaft auf dem LXC Container mit den anderen Aktienanalyse-Teilprojekten laufen

**Details**:
- Deployment auf aktienanalyse-lxc-120 (10.1.1.174)
- Integration mit bestehender Aktienanalyse-Infrastruktur
- Dauerhafte Ausf√ºhrung als Service/Daemon
- Gemeinsame Nutzung der vorhandenen Ressourcen (Datenbank, Mail-System, etc.)

**Technische Anforderungen**:
- systemd Service Integration
- Shared Data Access mit aktienanalyse-auswertung
- Nutzung des Enhanced Integrated Reporters
- Integration in bestehende Monitoring-Infrastruktur

**‚úÖ DATENBANK-INTEGRATION GEKL√ÑRT**:
- **Separate Datenbank**: `depot.db` f√ºr Trading-relevante Daten
- **Cross-System Integration**: Python-APIs f√ºr Daten-Austausch
- **Backup-Strategie**: Unabh√§ngige Sicherung beider Datenbanken
- **Schema-Management**: Separate Migrations f√ºr depot.db

**Verbleibende Fragen**:
- Soll es ein eigener Service oder Teil des bestehenden aktienanalyse-daemon werden?
- Sollen eigene Log-Dateien oder gemeinsame Logs verwendet werden?
- **Cross-System-Integration**: Wie wird die Performance-Synchronisation implementiert?
- **Daten-Mapping**: Welche Felder aus aktienanalyse.db werden f√ºr Vergleiche ben√∂tigt?
- **Sync-Scheduler**: Soll die Synchronisation zeitgesteuert oder event-basiert erfolgen?

### 5. üåê Northbound API (ohne Frontend)

**Anforderung**: Design und Implementation einer RESTful API f√ºr externe Frontend-Anbindung

**Details**:
- Vollst√§ndiger API-Zugriff auf alle Depot-Funktionen
- API-First Architektur f√ºr maximale Flexibilit√§t
- **Frontend-Abgrenzung**: Separates Projekt "aktienanalyse-frontend" f√ºr UI

**API-Funktionen (zu designen)**:
- Depot-√úbersicht und Portfolio-Status
- Positionen verwalten (CRUD-Operationen)
- Order-Management (Buy/Sell Orders)
- Performance-Daten und Statistiken
- Historische Daten und Charts
- Konfiguration und Einstellungen

**Technische Anforderungen**:
- RESTful API Design (OpenAPI/Swagger)
- Einfache lokale Authentifizierung (optional)
- JSON-basierte Daten√ºbertragung
- WebSocket f√ºr Real-time Updates (optional)

**‚úÖ FRONTEND-ABGRENZUNG GEKL√ÑRT**:
- **Kein Frontend**: aktienanalyse-verwaltung = Backend + API nur
- **Separates Projekt**: "aktienanalyse-frontend" f√ºr alle UI-Komponenten
- **API-Only-Fokus**: Vollst√§ndige REST-API f√ºr Frontend-Anbindung
- **Interface-Definition**: OpenAPI/Swagger f√ºr Frontend-Integration

**Vereinfachungen durch Single-User-Scope**:
- Keine komplexe Benutzerauthentifizierung erforderlich
- Keine Autorisierungslogik f√ºr verschiedene Benutzerrollen
- Keine Rate Limiting f√ºr API-Zugriffe notwendig
- Einfache lokale Konfiguration ausreichend

**Fragen zur Kl√§rung**:
- Welche API-Standards sollen verwendet werden? (REST, GraphQL, etc.)
- **API-Interface**: Welche spezifischen Endpoints f√ºr aktienanalyse-frontend ben√∂tigt?

### 6. üì° Backend Order-Management API

**Anforderung**: Es soll eine Backend-API geben, die f√ºr das Order-Management zust√§ndig ist und sich an den Vorgaben der Online-Plattformen orientiert

**Details**:
- Standardisierte Order-Management API nach Broker-Standards
- Kompatibilit√§t mit g√§ngigen Online-Broker APIs
- Abstraktionsschicht zwischen lokalem System und verschiedenen Brokern
- Einheitliche Order-Schnittstelle unabh√§ngig vom verwendeten Broker

**API-Standards Orientierung**:
- **Interactive Brokers API** (IB Gateway, TWS API)
- **Alpaca Trading API** (REST/WebSocket)
- **TD Ameritrade API** (REST-basiert)
- **E*TRADE API** (OAuth + REST)
- **Schwab API** (REST + OAuth)
- **FIX Protocol** (Financial Information eXchange)

**Order-Management Funktionen**:
- Order Placement (Market, Limit, Stop, Stop-Limit)
- Order Modification und Cancellation
- Order Status Tracking und Updates
- Position Management und Monitoring
- Account Information und Balances
- Real-time Market Data Integration

**Technische Anforderungen**:
- **Broker-Abstraction Layer**: Einheitliche API f√ºr verschiedene Broker
- **Order State Management**: Tracking von Order-Lifecycle
- **Error Handling**: Robust error handling f√ºr API-Failures
- **Broker Rate Limiting**: Compliance mit Broker-Rate-Limits
- **Reconnection Logic**: Automatische Wiederverbindung bei Verbindungsabbr√ºchen
- **Order Persistence**: Lokale Speicherung von Orders und Status

**Vereinfachungen durch Single-User-Scope**:
- Keine Benutzer-spezifische Order-Isolation erforderlich
- Keine Session-Management oder Token-Verwaltung
- Einfache lokale Konfigurationsdateien f√ºr Broker-Credentials
- Keine mandantenf√§hige Datenbanktrennung

**Fragen zur Kl√§rung**:
- Welche spezifischen Broker-APIs sollen als Referenz dienen?
- Sollen mehrere Broker gleichzeitig unterst√ºtzt werden?
- Wie soll das Failover zwischen Brokern funktionieren?
- Welche Order-Typen haben h√∂chste Priorit√§t f√ºr die Implementierung?

---

## ‚ùì Offene Fragen f√ºr weitere Details

### üîß Technische Grundlagen
1. ‚úÖ **Broker-Auswahl**: **Bitpanda Pro** - REST API + WebSocket Support
2. ‚úÖ **Order-Typen**: Market, Limit, Stop-Limit + erweiterte Typen (GtC, GtT, IoC, FoK)
3. **Risikomanagement**: Sollen automatische Stopp-Loss oder Take-Profit-Orders gesetzt werden?
4. **Datenquellen**: Bitpanda Pro Market Data Feed + externe Quellen?
5. **API-Design**: REST (Bitpanda-kompatibel) + WebSocket f√ºr Real-time
6. ‚úÖ **Frontend-Technologie**: **Separates Projekt "aktienanalyse-frontend"**
7. ‚úÖ **Asset-Support gekl√§rt**: Bitpanda Pro unterst√ºtzt **Aktien + ETFs + Crypto**

### üìä Funktionale Details  
7. ‚úÖ **Aktien-Quellen**: **aktienanalyse-auswertung** als prim√§re Datenquelle best√§tigt
8. **Import-Filter**: Performance-basierte √úbernahme + zus√§tzliche Filterkriterien?
9. **Benachrichtigungen**: Wie sollen Order-Ausf√ºhrungen und neue √úbernahmen kommuniziert werden?
10. **Order-Priorit√§t**: Welche Order-Typen haben h√∂chste Implementierungspriorit√§t?
11. **Performance-Mapping**: Wie aktienanalyse-Scores mit Depot-Rankings vergleichen?
12. **Sync-Frequenz**: Zeitgesteuerte vs. event-basierte Synchronisation?

### üèóÔ∏è Architektur
13. **Service-Integration**: Eigener Daemon oder Integration in bestehenden aktienanalyse-daemon?
14. ‚úÖ **Datenbank-Sharing**: **Separate depot.db** + Cross-Database-Sync mit aktienanalyse.db
15. **Broker-API-Referenz**: Welche spezifischen Broker-APIs als Vorbild?
16. **Multi-Broker-Support**: Sollen mehrere Broker gleichzeitig unterst√ºtzt werden?
17. **Failover-Strategie**: Wie soll das Failover zwischen Brokern funktionieren?
18. **Cross-System-Sync**: Wie Performance-Daten zwischen beiden Systemen abgleichen?

### ‚úÖ Vereinfacht durch Single-User-Scope
~~**API-Authentifizierung**~~: Nicht erforderlich f√ºr privates System  
~~**Benutzerinterface-Berechtigung**~~: Vollzugriff f√ºr einzigen Benutzer  
~~**API-Scope-Management**~~: Nur interne Nutzung  
~~**Multi-Tenant-Sicherheit**~~: Nicht relevant f√ºr Einzelbenutzer  
~~**Session-Management**~~: Keine Benutzer-Sessions erforderlich  
~~**Mandantenf√§higkeit**~~: Keine Datenbanktrennung zwischen Benutzern  
~~**Berechtigungsmatrix**~~: Vollzugriff auf alle Funktionen f√ºr Einzelbenutzer  
~~**Audit-Logs**~~: Vereinfachte Protokollierung ohne Benutzer-Tracking

## üèóÔ∏è Architektur-√úberlegungen

### LXC Container Integration
- **Bestehende Infrastruktur**: aktienanalyse-lxc-120 (10.1.1.174)
- **Shared Services**: Postfix Mail-Server, Enhanced Reporter, /opt Report-Speicherung
- **Database**: Erwiterung der bestehenden aktienanalyse.db oder neue depot.db?
- **Monitoring**: Integration in bestehendes System-Monitoring

### M√∂gliche Architektur-Ans√§tze
1. **Monolithisch**: Erweiterung des bestehenden aktienanalyse-daemon
2. **Microservice**: Separater depot-service mit API-Kommunikation  
3. **Hybrid**: Separate Anwendung mit geteilten Ressourcen
4. **API-First**: Backend-Service + Northbound API + separates Frontend

### API-First Architektur mit Order-Management (Empfohlen)
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Frontend      ‚îÇ    ‚îÇ  Northbound API  ‚îÇ    ‚îÇ  Depot-Service  ‚îÇ
‚îÇ  (Web/Mobile)   ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ    (REST/JSON)   ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ   (Backend)     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ                        ‚îÇ
                                ‚îÇ                        ‚ñº
                         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                         ‚îÇ API Gateway ‚îÇ        ‚îÇ   Shared Data    ‚îÇ
                         ‚îÇ (Auth/Rate) ‚îÇ        ‚îÇ (aktienanalyse.db)‚îÇ
                         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                         ‚îÇ
                                                         ‚ñº
                         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                         ‚îÇ      Order-Management Backend API       ‚îÇ
                         ‚îÇ    (Broker-Abstraction Layer)          ‚îÇ
                         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                           ‚îÇ
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ                      ‚îÇ                      ‚îÇ
                    ‚ñº                      ‚ñº                      ‚ñº
            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
            ‚îÇ Interactive   ‚îÇ    ‚îÇ    Alpaca     ‚îÇ    ‚îÇ  TD Ameritrade‚îÇ
            ‚îÇ   Brokers     ‚îÇ    ‚îÇ   Trading     ‚îÇ    ‚îÇ      API      ‚îÇ
            ‚îÇ     API       ‚îÇ    ‚îÇ     API       ‚îÇ    ‚îÇ               ‚îÇ
            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Single-User API-First Architektur**:
- ‚úÖ **Frontend-Flexibilit√§t** (Web, Mobile, Desktop)
- ‚úÖ **Broker-Abstraction Layer** f√ºr Multi-Broker-Support
- ‚úÖ **Standardisierte Order-API** nach Broker-Vorgaben
- ‚úÖ **Saubere Trennung** zwischen UI, Business Logic und Broker-Integration
- ‚úÖ **Failover-Mechanismen** zwischen verschiedenen Brokern
- ‚úÖ **Einheitliche Order-Schnittstelle** unabh√§ngig vom Broker

**Vereinfachungen f√ºr privaten Gebrauch**:
- üîì **Keine komplexe Authentifizierung** - lokaler Zugriff ohne Login
- üìù **Einfache Konfiguration** - lokale Config-Dateien statt User-Management
- üöÄ **Schnellere Entwicklung** - Fokus auf Funktionalit√§t statt Sicherheitsfeatures
- üîß **Direkte API-Zugriffe** - keine Rate-Limiting oder Permission-Checks
- üíæ **Einfache Datenhaltung** - Single-User-Schema ohne Mandantentrennung

---

## üí∞ Priorisierung der Implementierung

### Phase 1: Core Module-Entwicklung (üî¥ Kritisch)

#### 1. üìä **core-depot Modul**
**Sub-Module-Struktur**:
```
core-depot/
‚îú‚îÄ‚îÄ position-manager/     # Position CRUD
‚îú‚îÄ‚îÄ order-manager/        # Order Lifecycle
‚îú‚îÄ‚îÄ trade-history/        # Trade-Historie
‚îî‚îÄ‚îÄ portfolio-calculator/ # Portfolio-Aggregation
```
- SQLite Datenbank-Schema (20 Tables)
- Position-Management mit CRUD-Operationen
- Order State Machine und Lifecycle-Management
- Portfolio-√úbersicht und Aggregation

#### 2. üßÆ **performance-engine Modul**
**Pipeline-Architektur**:
```
performance-engine/
‚îú‚îÄ‚îÄ tax-calculator/       # Steuer-Engine (KESt, SolZ, KiSt)
‚îú‚îÄ‚îÄ fee-tracker/         # Geb√ºhren-Berechnung
‚îú‚îÄ‚îÄ performance-metrics/ # ROI, Sharpe-Ratio etc.
‚îî‚îÄ‚îÄ ranking-engine/      # Multi-Kriterien-Ranking
```
- **Steuerberechnung nach aktuellem deutschen Steuerrecht (2025)**
- **KEINE Steueroptimierungen**: Keine Abschreibungen, Loss-Harvesting oder komplexe Optimierungen
- **Standard-S√§tze**: 25% KESt + 5,5% SolZ + opt. 8%/9% KiSt
- Geb√ºhren-Tracking und Netto-Performance-Berechnung
- Multi-Kriterien-Algorithmus (40% Netto, 30% Annualisiert, 30% Risk-Adjusted)
- Performance-Ranking und automatische Depot-Sortierung

#### 3. üóÑÔ∏è **data-layer Modul**
**Database-Abstraction**:
```
data-layer/
‚îú‚îÄ‚îÄ depot-repository/     # depot.db Operations
‚îú‚îÄ‚îÄ schema-manager/       # Database Migrations
‚îú‚îÄ‚îÄ query-optimizer/      # Performance Optimierung
‚îî‚îÄ‚îÄ backup-manager/       # Backup-Strategien
```
- Einheitliche Database-Abstraktion f√ºr alle Module
- Schema-Management und Migrations
- Cross-Database-Queries f√ºr aktienanalyse.db Integration

### Phase 2: External Integration Module (üü° Wichtig)

#### 4. üîÑ **cross-system-sync Modul**
**Scheduled-Sync-Architektur**:
```
cross-system-sync/
‚îú‚îÄ‚îÄ sync-service/          # Periodischer Sync
‚îú‚îÄ‚îÄ data-mapper/          # aktienanalyse.db ‚Üí depot.db
‚îú‚îÄ‚îÄ comparison-engine/     # Performance-Vergleich
‚îî‚îÄ‚îÄ import-processor/     # Batch-Import Logic (0 Bestand)
```
- Regelm√§√üige Synchronisation mit aktienanalyse-auswertung
- Performance-Vergleich zwischen Depot-Rankings und Analyse-Ergebnissen
- Automatische √úbernahme besserer Aktien in Watchlist
- Cross-Database-Queries mit Fehlerbehandlung

#### 5. üì° **broker-integration Modul**
**Event-Driven Broker-Abstraction**:
```
broker-integration/
‚îú‚îÄ‚îÄ broker-abstraction/    # Generic Broker Interface
‚îú‚îÄ‚îÄ bitpanda-adapter/     # Bitpanda-spezifische Impl.
‚îú‚îÄ‚îÄ order-executor/       # Event-driven Order-Ausf√ºhrung
‚îú‚îÄ‚îÄ market-data-feed/     # Real-time Event-Publishing
‚îú‚îÄ‚îÄ cost-tracker/        # Event-basierte Geb√ºhren-Integration
‚îî‚îÄ‚îÄ event-handler/       # Event Bus Integration
    ‚îú‚îÄ‚îÄ order-events/    # trading.orders.* Event Publishing
    ‚îú‚îÄ‚îÄ market-events/   # market.data.* Event Publishing  
    ‚îú‚îÄ‚îÄ cost-events/     # trading.costs.* Event Publishing
    ‚îî‚îÄ‚îÄ broker-health/   # system.health.broker.* Events
```
- **Event-Driven Architecture**: Alle Broker-Aktionen √ºber Event Bus
- **Order Events**: `trading.order.created/executed/failed` f√ºr Cross-System Updates
- **Market Data Events**: `market.data.realtime.*` f√ºr Live-Updates
- **Cost Events**: `trading.cost.calculated` f√ºr Performance-Engine
- **Health Events**: `system.health.broker.*` f√ºr Monitoring

### Phase 3: Northbound API Module (üü¢ Erweiterung)

#### 6. üåê **northbound-api Modul**
**API-First-Architektur**:
```
northbound-api/
‚îú‚îÄ‚îÄ api-gateway/          # Zentraler API-Router
‚îú‚îÄ‚îÄ depot-endpoints/      # Depot-Verwaltung API
‚îú‚îÄ‚îÄ performance-api/      # Performance-Metrics API
‚îú‚îÄ‚îÄ order-api/           # Order-Management API
‚îú‚îÄ‚îÄ watchlist-api/       # Watchlist-Verwaltung API
‚îú‚îÄ‚îÄ sync-api/            # Cross-System-Sync API
‚îú‚îÄ‚îÄ websocket-hub/       # Real-time Updates
‚îî‚îÄ‚îÄ openapi-docs/        # Swagger-Dokumentation
```
- RESTful API Design mit standardisierten HTTP-Methoden
- OpenAPI/Swagger Dokumentation f√ºr aktienanalyse-frontend Integration
- JSON-basierte Daten√ºbertragung mit Schema-Validierung
- WebSocket-Support f√ºr Real-time Updates (Portfolio-√Ñnderungen, Order-Status)
- **Performance-API**: Brutto/Netto-Performance Endpoints mit Zeitraum-Filterung
- **Ranking-API**: Position-Rankings mit konfigurierbaren Sortierkriterien
- **Cross-System-API**: aktienanalyse-Vergleichs-Endpoints mit Synchronisation

#### 7. ‚öôÔ∏è **service-foundation Modul**
**Infrastructure-Support**:
```
service-foundation/
‚îú‚îÄ‚îÄ config-manager/      # Zentrale Konfiguration
‚îú‚îÄ‚îÄ logging-system/      # Strukturierte Logs
‚îú‚îÄ‚îÄ health-monitor/      # System Health Checks
‚îú‚îÄ‚îÄ scheduler/           # Task-Scheduling
‚îú‚îÄ‚îÄ notification-hub/    # Benachrichtigungen
‚îú‚îÄ‚îÄ backup-service/      # Automatische Backups
‚îî‚îÄ‚îÄ systemd-integration/ # Service-Management
```
- Systemd Service Integration f√ºr dauerhafte Ausf√ºhrung
- Zentrale Konfigurationsverwaltung (YAML/JSON-basiert)
- Strukturiertes Logging mit Log-Rotation
- Health-Check-Endpoints f√ºr Monitoring
- Task-Scheduler f√ºr periodische Jobs (Sync, Backup, Cleanup)
- Notification-System f√ºr wichtige Events

### Phase 4: Advanced Features Module (üîµ Zusatzfeatures)

#### 8. üß™ **testing-framework Modul**
**Test-Infrastructure**:
```
testing-framework/
‚îú‚îÄ‚îÄ unit-tests/          # Modul-spezifische Tests
‚îú‚îÄ‚îÄ integration-tests/   # Cross-Module-Tests
‚îú‚îÄ‚îÄ mock-broker/         # Bitpanda Pro Mock-Server
‚îú‚îÄ‚îÄ test-data/          # Test-Datens√§tze
‚îú‚îÄ‚îÄ performance-tests/   # Load/Performance Tests
‚îî‚îÄ‚îÄ e2e-tests/          # End-to-End Tests
```
- Mock-Broker f√ºr Development und Testing ohne echte API-Calls
- Comprehensive Test-Suite f√ºr alle Module
- Performance-Tests f√ºr Ranking-Algorithmen
- Integration-Tests f√ºr Cross-System-Sync
- End-to-End Tests f√ºr komplette Trading-Workflows

#### 9. üî¨ **advanced-features Modul** (Optional)
**Extended Functionality**:
```
advanced-features/
‚îú‚îÄ‚îÄ tax-optimizer/       # Steueroptimierung
‚îú‚îÄ‚îÄ rebalancing-engine/  # Portfolio-Rebalancing
‚îú‚îÄ‚îÄ strategy-framework/  # Trading-Strategien
‚îú‚îÄ‚îÄ alert-system/       # Performance-Alerts
‚îî‚îÄ‚îÄ analytics-engine/   # Advanced Analytics
```
- **Steueroptimierung**: Verlustverrechnungs-Vorschl√§ge und Tax-Loss-Harvesting
- **Portfolio-Rebalancing**: Automatische Optimierung basierend auf Cross-System Performance-Ranking
- **Trading-Strategien**: Framework f√ºr regelbasierte Kauf-/Verkaufentscheidungen
- **Performance-Alerts**: Benachrichtigungen bei neuen aktienanalyse-Empfehlungen
- **Enhanced Analytics**: Erweiterte Reportings mit Steuer-/Geb√ºhren-Breakdown

**Modulare Deployment-Optionen**:
- **Development**: Alle Module als Python-Packages in einer Anwendung
- **Production-Monolith**: Alle Module in einem systemd-Service
- **Microservices**: Kritische Module (core-depot, broker-integration) als separate Services
- **Hybrid**: Flexibler Mix je nach Performance- und Maintenance-Anforderungen

---

## üõ†Ô∏è Technische Entscheidungen

### Datenbank-Strategie
**‚úÖ ENTSCHIEDEN: Separate `depot.db` Datenbank**

**Vorteile der separaten Datenbank**:
- ‚úÖ **Saubere Dom√§nen-Trennung**: Depot-Management vs. Aktienanalyse
- ‚úÖ **Unabh√§ngige Schema-Evolution**: Keine Konflikte bei Updates
- ‚úÖ **Separate Backup-Strategien**: Unabh√§ngige Datensicherung
- ‚úÖ **Microservice-Ready**: Vorbereitung f√ºr Service-Trennung
- ‚úÖ **Klare Zust√§ndigkeiten**: depot.db nur f√ºr Trading-relevante Daten

**Datenbank-Architektur `depot.db` (20 Tables)**:
```sql
-- Core Tables f√ºr Depot-Management (7)
depots              # Depot-Konfiguration und Metadaten
positions           # Aktuelle Positionen (Symbol, Anzahl, Durchschnittspreis)
orders              # Order-Management (Status, Typ, Ausf√ºhrung)
trades              # Ausgef√ºhrte Trades (Buy/Sell Historie)
instruments         # Verf√ºgbare Aktien/ETFs von Bitpanda
portfolio_snapshots # Historische Portfolio-Performance
account_balances    # Cash-Positionen und verf√ºgbare Mittel

-- Enhanced Performance-Tracking Tables (6)
trade_costs         # Kauf-/Verkaufgeb√ºhren, Spreads, B√∂rsenplatzentgelte
tax_calculations    # Standard-Steuerberechnung pro Trade (25% KESt + 5,5% SolZ + opt. KiSt)
dividends           # Dividenden-Historie (Brutto/Netto, Quellensteuer)
tax_simple_tracking # Einfache Steuer-Erfassung OHNE Optimierungen oder Verlustverrechnung
currency_rates      # Historische Wechselkurse f√ºr Fremdw√§hrungs-Assets
performance_metrics # Berechnete Performance-Kennzahlen (Brutto/Netto nach Standardsteuer)

-- Performance-Ranking & Comparison Tables (4)
position_rankings   # Zeitraum-spezifische Performance-Rankings nach Netto-Gewinn
benchmark_data      # Markt-Indices f√ºr Vergleiche (DAX, S&P500, MSCI World)
risk_metrics        # Volatilit√§t, Sharpe-Ratio, Maximum Drawdown pro Position
rebalancing_suggestions # Automatische Portfolio-Optimierungsvorschl√§ge

-- Integration Tables (5)
broker_sync_log     # Synchronisation mit Bitpanda Pro
import_queue        # Externe Aktien-Imports (Warteschlange) 
notifications       # Order-Ausf√ºhrung Benachrichtigungen
aktienanalyse_sync  # Cross-System Performance-Synchronisation
cross_system_rankings # Vergleich zwischen Depot- und Analyse-Performance
```

**Performance-Ranking Algorithmus**:
```python
# Zeitraum-normalisierte Netto-Performance-Berechnung
def calculate_position_ranking(position, time_period):
    net_return = (current_value - purchase_value - total_costs - taxes) / investment
    annualized_return = ((1 + net_return) ** (365/holding_days)) - 1
    risk_adjusted_return = annualized_return / volatility  # Sharpe-like ratio
    
    ranking_score = (
        net_return * 0.4 +           # Absolute Netto-Performance
        annualized_return * 0.3 +    # Zeitraum-normalisiert  
        risk_adjusted_return * 0.3   # Risk-adjusted
    )
    return ranking_score

# Cross-System Performance-Vergleich mit aktienanalyse-auswertung
def compare_with_aktienanalyse():
    depot_rankings = get_depot_performance_rankings()
    analyse_rankings = query_aktienanalyse_db()
    
    # Finde bessere Aktien aus aktienanalyse-auswertung
    better_stocks = []
    worst_depot_score = min(depot_rankings.values())
    
    for stock, analyse_score in analyse_rankings.items():
        if stock not in depot_rankings:  # Nicht im Depot
            if analyse_score > worst_depot_score:  # Besser als schlechteste Depot-Position
                better_stocks.append({
                    'symbol': stock,
                    'analyse_score': analyse_score,
                    'potential_improvement': analyse_score - worst_depot_score
                })
    
    # Automatische √úbernahme in Depot (0 Bestand)
    for stock in better_stocks:
        add_to_depot_watchlist(stock['symbol'], quantity=0)
    
    return better_stocks
```

**Inter-Database Communication**:
- **Cross-Database Queries**: Bei Bedarf JOIN √ºber Python-Layer
- **Shared Configuration**: Gemeinsame Config-Dateien f√ºr beide Systeme
- **Data Sharing**: RESTful APIs f√ºr Daten-Austausch zwischen Services

### Service-Integration-Strategie
**‚úÖ ENTSCHIEDEN: Modulare Domain-Driven Architektur mit flexibler Deployment-Strategie**

**8-Module-Architektur**:
```
aktienanalyse-verwaltung/
‚îú‚îÄ‚îÄ üìä core-depot/              # Domain: Depot-Management (4 Sub-Module)
‚îú‚îÄ‚îÄ üßÆ performance-engine/      # Domain: Performance-Berechnung (4 Sub-Module)
‚îú‚îÄ‚îÄ üóÑÔ∏è data-layer/             # Domain: Database-Abstraction (4 Sub-Module)
‚îú‚îÄ‚îÄ üîÑ cross-system-sync/       # Domain: aktienanalyse Integration (4 Sub-Module)
‚îú‚îÄ‚îÄ üì° broker-integration/      # Domain: Bitpanda Pro Integration (5 Sub-Module)
‚îú‚îÄ‚îÄ üåê northbound-api/          # Domain: REST API Layer (8 Sub-Module)
‚îú‚îÄ‚îÄ ‚öôÔ∏è service-foundation/      # Domain: Service Infrastructure (7 Sub-Module)
‚îî‚îÄ‚îÄ üß™ testing-framework/      # Domain: Test Infrastructure (6 Sub-Module)
```

**‚úÖ HYBRID-DEPLOYMENT-STRATEGIE (Empfohlen)**:
```
Deployment-Architektur:
‚îú‚îÄ‚îÄ core-services/              # Monolith (Performance-kritisch)
‚îÇ   ‚îú‚îÄ‚îÄ core-depot/            # Position/Order Management
‚îÇ   ‚îú‚îÄ‚îÄ performance-engine/    # Performance-Berechnungen
‚îÇ   ‚îî‚îÄ‚îÄ data-layer/           # Database-Abstraction
‚îú‚îÄ‚îÄ integration-services/       # Separate Services
‚îÇ   ‚îú‚îÄ‚îÄ sync-service/          # cross-system-sync als Service
‚îÇ   ‚îî‚îÄ‚îÄ broker-gateway/        # broker-integration als Service
‚îú‚îÄ‚îÄ api-layer/                 # API-Gateway als Service
‚îÇ   ‚îî‚îÄ‚îÄ northbound-api/       # REST + WebSocket API
‚îî‚îÄ‚îÄ infrastructure/            # Shared Foundation
    ‚îî‚îÄ‚îÄ service-foundation/    # Logging, Config, Health
```

**Service-Kommunikation**:
- **In-Process**: Module innerhalb core-services (niedrige Latenz)
- **REST APIs**: Inter-Service Communication (broker-gateway ‚Üî sync-service)
- **Shared Database**: depot.db f√ºr alle Services zug√§nglich
- **WebSocket**: Real-time Updates (broker-gateway ‚Üí api-layer)

**Modulare Architektur-Vorteile**:
- ‚úÖ **Domain-Driven Design**: Klare fachliche Abgrenzung der Module
- ‚úÖ **Parallel Development**: 8 Module k√∂nnen unabh√§ngig entwickelt werden
- ‚úÖ **Isolierte Testing**: Jedes Modul mit eigener Test-Suite
- ‚úÖ **Flexible Deployment**: Development-Monolith ‚Üí Production-Hybrid ‚Üí Microservices
- ‚úÖ **Service Evolution**: Module k√∂nnen schrittweise als Services ausgelagert werden
- ‚úÖ **Interface-Stabilit√§t**: Definierte Interfaces bleiben bei Deployment-√Ñnderungen stabil
- ‚úÖ **Performance-Optimierung**: Kritische Module (core-depot) bleiben im Monolith
- ‚úÖ **Skalierbarkeit**: Nur ben√∂tigte Services (broker-gateway) horizontal skalieren

### Broker-API-Standards
**‚úÖ PRIM√ÑRE IMPLEMENTIERUNG: Bitpanda Pro API**

**Bitpanda Pro API Spezifikation**:
- **Base URL**: `https://api.exchange.bitpanda.com/public/v1`
- **Authentifizierung**: `Authorization: Bearer <API_KEY>`
- **Rate Limit**: 120 Requests/Minute (HTTP 429 bei √úberschreitung)
- **Content-Type**: `application/json`

**Core Trading Endpoints**:
```
POST /account/orders          # Order-Placement
DELETE /account/orders/{id}   # Order-Cancellation  
GET /account/orders           # Order-History
GET /account/balances         # Account-Balances
GET /account/trades           # Trade-History
GET /instruments              # Verf√ºgbare Instrumente
GET /currencies               # Unterst√ºtzte W√§hrungen
```

**WebSocket-Streams (Real-time)**:
- `wss://streams.exchange.bitpanda.com/` 
- Account Feed: Balance-Updates, Order-Status
- Market Data: Ticker, OrderBook, Candlesticks
- Parallel WebSocket-Connections supported

**Python Integration (Referenz)**:
```python
# Basierend auf bitpanda-aio Client
client = BitpandaClient(api_key="YOUR_API_KEY")
await client.create_market_order(
    instrument_code="BTC_EUR", 
    side=OrderSide.BUY, 
    amount="1.0"
)
```

**‚úÖ VOLLST√ÑNDIGER ASSET-SUPPORT BEST√ÑTIGT**:
- **Aktien**: Direkter Zugang zu Aktien verschiedener M√§rkte
- **ETFs**: Exchange Traded Funds verf√ºgbar
- **Crypto**: Bitcoin, Ethereum und weitere Kryptow√§hrungen
- **Fiat**: EUR, USD f√ºr Trading-Pairs und Settlements
- **Single-Broker-L√∂sung**: Keine zus√§tzlichen Broker erforderlich

---

## üìã N√§chste Schritte

### Unmittelbare Aufgaben
1. ‚úÖ **Broker-Auswahl finalisiert** - **Bitpanda Pro** mit REST + WebSocket API
2. ‚úÖ **Asset-Support best√§tigt** - **Aktien + ETFs + Crypto** vollst√§ndig unterst√ºtzt
3. **Order-Typen priorisieren** - Market, Limit, Stop-Limit Implementierungsreihenfolge
4. ‚úÖ **Datenbank-Strategie entschieden** - **Separate `depot.db` Datenbank**
5. **Service-Architektur w√§hlen** - Monolith vs. Microservice

### Technische Vorbereitung
1. **API-Standards definieren** - REST/GraphQL Entscheidung
2. ‚úÖ **Frontend-Abgrenzung gekl√§rt** - **Separates Projekt "aktienanalyse-frontend"**
3. **Deployment-Strategie** - systemd Service-Integration planen
4. **Testing-Strategie** - Mock-Broker f√ºr Development definieren
5. **API-Interface-Design** - OpenAPI/Swagger f√ºr aktienanalyse-frontend Integration

### Dokumentation
1. **API-Spezifikation** - OpenAPI/Swagger Schema f√ºr aktienanalyse-frontend
2. **Broker-Integration-Guide** - Schritt-f√ºr-Schritt Anleitung
3. **Deployment-Dokumentation** - LXC Container Setup-Guide
4. **API-Documentation** - Vollst√§ndige API-Referenz f√ºr Frontend-Integration
